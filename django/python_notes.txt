One item tuple, must use comma (1,) and empty tuple ()
"is" operator is for reference check. a is b, a is not None. Whereas == is value equal.

2 in (4, "frog", 2) => True

Python's and, or return the operand that determined the result (not True or False)
five = 5
two = 2
five and two => 2

In Python, block of code that is sequence of one or more statements is called a suite. B/c 
some of Python's syntax requires that a suite be present, Python provides keyword pass which is a 
statement that does nothing and that can be used where a suite is required

12 / 3 results in 4.0 in Python. if need int, cast the result int(12/3) or use truncating division
operation //

seeds = ["sesame", "sunflower"]
seeds += ["poppy"]

for entry in ["foo", "bar"]
  print entry
else
  print "have nothing"

try
  //stuff
except exception1 as variable1:
  //handle
except exception2 as variable2:
  //handle 2
else
  //me optional

Binary numbers are written with a leading 0b, octal numbers with a leading 0o.*, and hexadecimal numbers with a leading 0x.

(2145).bit_length() returns 12 (number of bits required to represent the int it is called on)

def equal_float(a, b):
  return abs(a-b) <= sys.float_info.epsilon

sys.float.epsilon is effectively the smallest difference that the machine can distinguish between two 
floating numbers.

14.25.hex() => floating number as hex string
float.fromhex(string)

z = -89.5+2.125j
z.real, z.imag => (-89.5, 2.125)
The functions in the math module do not work with complex numbers. This is a deliberate design decision 
that ensures that users of the math module get exceptions rather than silently getting complex numbers in some situations. Users of complex numbers can import cmath module.

longStr = ("Stuff here "
           "what here.")

Using + to concatenate and += to append is not particulary efficent when many strings are involved. For joining lots of strings it is usually best to use the str.join() method
s = s[:12] + "wo " + s[12:]
seq[start:end:step] being full syntax
if negative step is given, start index defaults to -1 and starts from the end

The local variables that are currently in scope are available from the built in locals() function.
element = "Silver"
number = 47
"Element {number} is {element}".format(**locals()) => "Element 47 is Silver"
If we need to include braces inside format strings, we need to double them up
"{{{0}}} {1} ;-}}".format("In braces", "Not") => "{In braces} Not ;-}"

Refer to format specification as is rather lengthy and full featured
"{0:-^25}".format(s) # - fill, center align, minimum width 25 
{field_name!conversion:format_specification} with conversion being 
s: string form, r: representational form, a representational form but only using ASCII characters



